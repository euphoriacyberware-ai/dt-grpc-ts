// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: imageService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DeviceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case phone // = 0
  case tablet // = 1
  case laptop // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .phone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .phone
    case 1: self = .tablet
    case 2: self = .laptop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .phone: return 0
    case .tablet: return 1
    case .laptop: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [DeviceType] = [
    .phone,
    .tablet,
    .laptop,
  ]

}

struct EchoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  /// The secret use to authenticate if needed.
  var sharedSecret: String {
    get {return _sharedSecret ?? String()}
    set {_sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  var hasSharedSecret: Bool {return self._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  mutating func clearSharedSecret() {self._sharedSecret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sharedSecret: String? = nil
}

struct EchoReply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var files: [String] = []

  var override: MetadataOverride {
    get {return _override ?? MetadataOverride()}
    set {_override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  var hasOverride: Bool {return self._override != nil}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  mutating func clearOverride() {self._override = nil}

  /// If this is true, sharedSecret is required.
  var sharedSecretMissing: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _override: MetadataOverride? = nil
}

struct FileListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var files: [String] = []

  var filesWithHash: [String] = []

  /// The secret use to authenticate if needed.
  var sharedSecret: String {
    get {return _sharedSecret ?? String()}
    set {_sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  var hasSharedSecret: Bool {return self._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  mutating func clearSharedSecret() {self._sharedSecret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sharedSecret: String? = nil
}

struct FileExistenceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var files: [String] = []

  var existences: [Bool] = []

  var hashes: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MetadataOverride: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var models: Data = Data()

  var loras: Data = Data()

  var controlNets: Data = Data()

  var textualInversions: Data = Data()

  var upscalers: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// parameters in this Request is exactly same as generate function in ImageGenerator
struct ImageGenerationRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Image data as sha256 content.
  var image: Data {
    get {return _storage._image ?? Data()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  var scaleFactor: Int32 {
    get {return _storage._scaleFactor}
    set {_uniqueStorage()._scaleFactor = newValue}
  }

  /// Optional  Mask data as sha256 content.
  var mask: Data {
    get {return _storage._mask ?? Data()}
    set {_uniqueStorage()._mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  var hasMask: Bool {return _storage._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  mutating func clearMask() {_uniqueStorage()._mask = nil}

  /// List of hints
  var hints: [HintProto] {
    get {return _storage._hints}
    set {_uniqueStorage()._hints = newValue}
  }

  /// Optional prompt string
  var prompt: String {
    get {return _storage._prompt}
    set {_uniqueStorage()._prompt = newValue}
  }

  /// Optional negative prompt string
  var negativePrompt: String {
    get {return _storage._negativePrompt}
    set {_uniqueStorage()._negativePrompt = newValue}
  }

  /// Configuration data as bytes (FlatBuffer)
  var configuration: Data {
    get {return _storage._configuration}
    set {_uniqueStorage()._configuration = newValue}
  }

  /// Override the existing metadata on various Zoo objects.
  var override: MetadataOverride {
    get {return _storage._override ?? MetadataOverride()}
    set {_uniqueStorage()._override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  var hasOverride: Bool {return _storage._override != nil}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  mutating func clearOverride() {_uniqueStorage()._override = nil}

  /// Keywords send to the ImageGenerator, not useful for local generation.
  var keywords: [String] {
    get {return _storage._keywords}
    set {_uniqueStorage()._keywords = newValue}
  }

  /// The name of the client.
  var user: String {
    get {return _storage._user}
    set {_uniqueStorage()._user = newValue}
  }

  /// The type of the device uses.
  var device: DeviceType {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  /// The image data as array of bytes. It is addressed by its sha256 content. This is modeled as content-addressable storage.
  var contents: [Data] {
    get {return _storage._contents}
    set {_uniqueStorage()._contents = newValue}
  }

  /// The secret use to authenticate if needed.
  var sharedSecret: String {
    get {return _storage._sharedSecret ?? String()}
    set {_uniqueStorage()._sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  var hasSharedSecret: Bool {return _storage._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  mutating func clearSharedSecret() {_uniqueStorage()._sharedSecret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct HintProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// hintType enum (key)
  var hintType: String = String()

  /// Repeated list of tensors with associated float
  var tensors: [TensorAndWeight] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message to store each tensor and its associated float score
struct TensorAndWeight: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tensor data as sha256 to the content.
  var tensor: Data = Data()

  /// Associated float score for the tensor
  var weight: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ImageGenerationSignpostProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signpost: ImageGenerationSignpostProto.OneOf_Signpost? = nil

  var textEncoded: ImageGenerationSignpostProto.TextEncoded {
    get {
      if case .textEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.TextEncoded()
    }
    set {signpost = .textEncoded(newValue)}
  }

  var imageEncoded: ImageGenerationSignpostProto.ImageEncoded {
    get {
      if case .imageEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageEncoded()
    }
    set {signpost = .imageEncoded(newValue)}
  }

  var sampling: ImageGenerationSignpostProto.Sampling {
    get {
      if case .sampling(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.Sampling()
    }
    set {signpost = .sampling(newValue)}
  }

  var imageDecoded: ImageGenerationSignpostProto.ImageDecoded {
    get {
      if case .imageDecoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageDecoded()
    }
    set {signpost = .imageDecoded(newValue)}
  }

  var secondPassImageEncoded: ImageGenerationSignpostProto.SecondPassImageEncoded {
    get {
      if case .secondPassImageEncoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassImageEncoded()
    }
    set {signpost = .secondPassImageEncoded(newValue)}
  }

  var secondPassSampling: ImageGenerationSignpostProto.SecondPassSampling {
    get {
      if case .secondPassSampling(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassSampling()
    }
    set {signpost = .secondPassSampling(newValue)}
  }

  var secondPassImageDecoded: ImageGenerationSignpostProto.SecondPassImageDecoded {
    get {
      if case .secondPassImageDecoded(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.SecondPassImageDecoded()
    }
    set {signpost = .secondPassImageDecoded(newValue)}
  }

  var faceRestored: ImageGenerationSignpostProto.FaceRestored {
    get {
      if case .faceRestored(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.FaceRestored()
    }
    set {signpost = .faceRestored(newValue)}
  }

  var imageUpscaled: ImageGenerationSignpostProto.ImageUpscaled {
    get {
      if case .imageUpscaled(let v)? = signpost {return v}
      return ImageGenerationSignpostProto.ImageUpscaled()
    }
    set {signpost = .imageUpscaled(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Signpost: Equatable, Sendable {
    case textEncoded(ImageGenerationSignpostProto.TextEncoded)
    case imageEncoded(ImageGenerationSignpostProto.ImageEncoded)
    case sampling(ImageGenerationSignpostProto.Sampling)
    case imageDecoded(ImageGenerationSignpostProto.ImageDecoded)
    case secondPassImageEncoded(ImageGenerationSignpostProto.SecondPassImageEncoded)
    case secondPassSampling(ImageGenerationSignpostProto.SecondPassSampling)
    case secondPassImageDecoded(ImageGenerationSignpostProto.SecondPassImageDecoded)
    case faceRestored(ImageGenerationSignpostProto.FaceRestored)
    case imageUpscaled(ImageGenerationSignpostProto.ImageUpscaled)

  }

  struct TextEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ImageEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Sampling: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var step: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ImageDecoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SecondPassImageEncoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SecondPassSampling: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var step: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SecondPassImageDecoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FaceRestored: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ImageUpscaled: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct ImageGenerationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Generated image data as bytes.
  var generatedImages: [Data] = []

  /// Single current signpost.
  var currentSignpost: ImageGenerationSignpostProto {
    get {return _currentSignpost ?? ImageGenerationSignpostProto()}
    set {_currentSignpost = newValue}
  }
  /// Returns true if `currentSignpost` has been explicitly set.
  var hasCurrentSignpost: Bool {return self._currentSignpost != nil}
  /// Clears the value of `currentSignpost`. Subsequent reads from it will return its default value.
  mutating func clearCurrentSignpost() {self._currentSignpost = nil}

  /// Collection of signposts.
  var signposts: [ImageGenerationSignpostProto] = []

  /// preview generating image data as bytes.
  var previewImage: Data {
    get {return _previewImage ?? Data()}
    set {_previewImage = newValue}
  }
  /// Returns true if `previewImage` has been explicitly set.
  var hasPreviewImage: Bool {return self._previewImage != nil}
  /// Clears the value of `previewImage`. Subsequent reads from it will return its default value.
  mutating func clearPreviewImage() {self._previewImage = nil}

  /// The scale factor of the image.
  var scaleFactor: Int32 {
    get {return _scaleFactor ?? 0}
    set {_scaleFactor = newValue}
  }
  /// Returns true if `scaleFactor` has been explicitly set.
  var hasScaleFactor: Bool {return self._scaleFactor != nil}
  /// Clears the value of `scaleFactor`. Subsequent reads from it will return its default value.
  mutating func clearScaleFactor() {self._scaleFactor = nil}

  /// Tags to track which server responded to the generation request.
  var tags: [String] = []

  /// The size of final image will be sent in the next payload.
  var downloadSize: Int64 {
    get {return _downloadSize ?? 0}
    set {_downloadSize = newValue}
  }
  /// Returns true if `downloadSize` has been explicitly set.
  var hasDownloadSize: Bool {return self._downloadSize != nil}
  /// Clears the value of `downloadSize`. Subsequent reads from it will return its default value.
  mutating func clearDownloadSize() {self._downloadSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentSignpost: ImageGenerationSignpostProto? = nil
  fileprivate var _previewImage: Data? = nil
  fileprivate var _scaleFactor: Int32? = nil
  fileprivate var _downloadSize: Int64? = nil
}

struct FileChunk: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Data = Data()

  var filename: String = String()

  var offset: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct InitUploadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the file to be uploaded.
  var filename: String = String()

  /// SHA-256 hash of the file.
  var sha256: Data = Data()

  /// Total size of the file in bytes.
  var totalSize: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UploadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chunkUploadSuccess: Bool = false

  var receivedOffset: Int64 = 0

  var message: String = String()

  var filename: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Union type for either an InitUploadRequest or FileChunk.
struct FileUploadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: FileUploadRequest.OneOf_Request? = nil

  /// Initial upload request to sync SHA and filename.
  var initRequest: InitUploadRequest {
    get {
      if case .initRequest(let v)? = request {return v}
      return InitUploadRequest()
    }
    set {request = .initRequest(newValue)}
  }

  /// File chunk data.
  var chunk: FileChunk {
    get {
      if case .chunk(let v)? = request {return v}
      return FileChunk()
    }
    set {request = .chunk(newValue)}
  }

  /// The secret use to authenticate if needed.
  var sharedSecret: String {
    get {return _sharedSecret ?? String()}
    set {_sharedSecret = newValue}
  }
  /// Returns true if `sharedSecret` has been explicitly set.
  var hasSharedSecret: Bool {return self._sharedSecret != nil}
  /// Clears the value of `sharedSecret`. Subsequent reads from it will return its default value.
  mutating func clearSharedSecret() {self._sharedSecret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    /// Initial upload request to sync SHA and filename.
    case initRequest(InitUploadRequest)
    /// File chunk data.
    case chunk(FileChunk)

  }

  init() {}

  fileprivate var _sharedSecret: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PHONE\0\u{1}TABLET\0\u{1}LAPTOP\0")
}

extension EchoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EchoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}sharedSecret\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sharedSecret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._sharedSecret {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EchoRequest, rhs: EchoRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._sharedSecret != rhs._sharedSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EchoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EchoReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{1}files\0\u{1}override\0\u{1}sharedSecretMissing\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._override) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sharedSecretMissing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 2)
    }
    try { if let v = self._override {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.sharedSecretMissing != false {
      try visitor.visitSingularBoolField(value: self.sharedSecretMissing, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EchoReply, rhs: EchoReply) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.files != rhs.files {return false}
    if lhs._override != rhs._override {return false}
    if lhs.sharedSecretMissing != rhs.sharedSecretMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FileListRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}files\0\u{1}filesWithHash\0\u{1}sharedSecret\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.filesWithHash) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sharedSecret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.filesWithHash.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filesWithHash, fieldNumber: 2)
    }
    try { if let v = self._sharedSecret {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FileListRequest, rhs: FileListRequest) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.filesWithHash != rhs.filesWithHash {return false}
    if lhs._sharedSecret != rhs._sharedSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileExistenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FileExistenceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}files\0\u{1}existences\0\u{1}hashes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.existences) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.hashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.existences.isEmpty {
      try visitor.visitPackedBoolField(value: self.existences, fieldNumber: 2)
    }
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.hashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FileExistenceResponse, rhs: FileExistenceResponse) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.existences != rhs.existences {return false}
    if lhs.hashes != rhs.hashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MetadataOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MetadataOverride"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}models\0\u{1}loras\0\u{1}controlNets\0\u{1}textualInversions\0\u{1}upscalers\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.models) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.loras) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.controlNets) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.textualInversions) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.upscalers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitSingularBytesField(value: self.models, fieldNumber: 1)
    }
    if !self.loras.isEmpty {
      try visitor.visitSingularBytesField(value: self.loras, fieldNumber: 2)
    }
    if !self.controlNets.isEmpty {
      try visitor.visitSingularBytesField(value: self.controlNets, fieldNumber: 3)
    }
    if !self.textualInversions.isEmpty {
      try visitor.visitSingularBytesField(value: self.textualInversions, fieldNumber: 4)
    }
    if !self.upscalers.isEmpty {
      try visitor.visitSingularBytesField(value: self.upscalers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MetadataOverride, rhs: MetadataOverride) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.loras != rhs.loras {return false}
    if lhs.controlNets != rhs.controlNets {return false}
    if lhs.textualInversions != rhs.textualInversions {return false}
    if lhs.upscalers != rhs.upscalers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageGenerationRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}image\0\u{1}scaleFactor\0\u{1}mask\0\u{1}hints\0\u{1}prompt\0\u{1}negativePrompt\0\u{1}configuration\0\u{1}override\0\u{1}keywords\0\u{1}user\0\u{1}device\0\u{1}contents\0\u{1}sharedSecret\0")

  fileprivate class _StorageClass {
    var _image: Data? = nil
    var _scaleFactor: Int32 = 0
    var _mask: Data? = nil
    var _hints: [HintProto] = []
    var _prompt: String = String()
    var _negativePrompt: String = String()
    var _configuration: Data = Data()
    var _override: MetadataOverride? = nil
    var _keywords: [String] = []
    var _user: String = String()
    var _device: DeviceType = .phone
    var _contents: [Data] = []
    var _sharedSecret: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _image = source._image
      _scaleFactor = source._scaleFactor
      _mask = source._mask
      _hints = source._hints
      _prompt = source._prompt
      _negativePrompt = source._negativePrompt
      _configuration = source._configuration
      _override = source._override
      _keywords = source._keywords
      _user = source._user
      _device = source._device
      _contents = source._contents
      _sharedSecret = source._sharedSecret
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._image) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._scaleFactor) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._mask) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._hints) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._prompt) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._negativePrompt) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._configuration) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._override) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._keywords) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._device) }()
        case 12: try { try decoder.decodeRepeatedBytesField(value: &_storage._contents) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._sharedSecret) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._image {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      if _storage._scaleFactor != 0 {
        try visitor.visitSingularInt32Field(value: _storage._scaleFactor, fieldNumber: 2)
      }
      try { if let v = _storage._mask {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      } }()
      if !_storage._hints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hints, fieldNumber: 4)
      }
      if !_storage._prompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prompt, fieldNumber: 5)
      }
      if !_storage._negativePrompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._negativePrompt, fieldNumber: 6)
      }
      if !_storage._configuration.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._configuration, fieldNumber: 7)
      }
      try { if let v = _storage._override {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._keywords.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._keywords, fieldNumber: 9)
      }
      if !_storage._user.isEmpty {
        try visitor.visitSingularStringField(value: _storage._user, fieldNumber: 10)
      }
      if _storage._device != .phone {
        try visitor.visitSingularEnumField(value: _storage._device, fieldNumber: 11)
      }
      if !_storage._contents.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._contents, fieldNumber: 12)
      }
      try { if let v = _storage._sharedSecret {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationRequest, rhs: ImageGenerationRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._image != rhs_storage._image {return false}
        if _storage._scaleFactor != rhs_storage._scaleFactor {return false}
        if _storage._mask != rhs_storage._mask {return false}
        if _storage._hints != rhs_storage._hints {return false}
        if _storage._prompt != rhs_storage._prompt {return false}
        if _storage._negativePrompt != rhs_storage._negativePrompt {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._override != rhs_storage._override {return false}
        if _storage._keywords != rhs_storage._keywords {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._contents != rhs_storage._contents {return false}
        if _storage._sharedSecret != rhs_storage._sharedSecret {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HintProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HintProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hintType\0\u{1}tensors\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hintType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tensors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hintType.isEmpty {
      try visitor.visitSingularStringField(value: self.hintType, fieldNumber: 1)
    }
    if !self.tensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tensors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HintProto, rhs: HintProto) -> Bool {
    if lhs.hintType != rhs.hintType {return false}
    if lhs.tensors != rhs.tensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TensorAndWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TensorAndWeight"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tensor\0\u{1}weight\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tensor) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.weight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tensor.isEmpty {
      try visitor.visitSingularBytesField(value: self.tensor, fieldNumber: 1)
    }
    if self.weight.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.weight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TensorAndWeight, rhs: TensorAndWeight) -> Bool {
    if lhs.tensor != rhs.tensor {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageGenerationSignpostProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}textEncoded\0\u{1}imageEncoded\0\u{1}sampling\0\u{1}imageDecoded\0\u{1}secondPassImageEncoded\0\u{1}secondPassSampling\0\u{1}secondPassImageDecoded\0\u{1}faceRestored\0\u{1}imageUpscaled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ImageGenerationSignpostProto.TextEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .textEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .textEncoded(v)
        }
      }()
      case 2: try {
        var v: ImageGenerationSignpostProto.ImageEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageEncoded(v)
        }
      }()
      case 3: try {
        var v: ImageGenerationSignpostProto.Sampling?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .sampling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .sampling(v)
        }
      }()
      case 4: try {
        var v: ImageGenerationSignpostProto.ImageDecoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageDecoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageDecoded(v)
        }
      }()
      case 5: try {
        var v: ImageGenerationSignpostProto.SecondPassImageEncoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassImageEncoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassImageEncoded(v)
        }
      }()
      case 6: try {
        var v: ImageGenerationSignpostProto.SecondPassSampling?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassSampling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassSampling(v)
        }
      }()
      case 7: try {
        var v: ImageGenerationSignpostProto.SecondPassImageDecoded?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .secondPassImageDecoded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .secondPassImageDecoded(v)
        }
      }()
      case 8: try {
        var v: ImageGenerationSignpostProto.FaceRestored?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .faceRestored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .faceRestored(v)
        }
      }()
      case 9: try {
        var v: ImageGenerationSignpostProto.ImageUpscaled?
        var hadOneofValue = false
        if let current = self.signpost {
          hadOneofValue = true
          if case .imageUpscaled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signpost = .imageUpscaled(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.signpost {
    case .textEncoded?: try {
      guard case .textEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .imageEncoded?: try {
      guard case .imageEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sampling?: try {
      guard case .sampling(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .imageDecoded?: try {
      guard case .imageDecoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .secondPassImageEncoded?: try {
      guard case .secondPassImageEncoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .secondPassSampling?: try {
      guard case .secondPassSampling(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .secondPassImageDecoded?: try {
      guard case .secondPassImageDecoded(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .faceRestored?: try {
      guard case .faceRestored(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .imageUpscaled?: try {
      guard case .imageUpscaled(let v)? = self.signpost else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto, rhs: ImageGenerationSignpostProto) -> Bool {
    if lhs.signpost != rhs.signpost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.TextEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".TextEncoded"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.TextEncoded, rhs: ImageGenerationSignpostProto.TextEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageEncoded"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.ImageEncoded, rhs: ImageGenerationSignpostProto.ImageEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.Sampling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".Sampling"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}step\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.step) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.step != 0 {
      try visitor.visitSingularInt32Field(value: self.step, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.Sampling, rhs: ImageGenerationSignpostProto.Sampling) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageDecoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageDecoded"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.ImageDecoded, rhs: ImageGenerationSignpostProto.ImageDecoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassImageEncoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassImageEncoded"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.SecondPassImageEncoded, rhs: ImageGenerationSignpostProto.SecondPassImageEncoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassSampling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassSampling"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}step\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.step) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.step != 0 {
      try visitor.visitSingularInt32Field(value: self.step, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.SecondPassSampling, rhs: ImageGenerationSignpostProto.SecondPassSampling) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.SecondPassImageDecoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".SecondPassImageDecoded"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.SecondPassImageDecoded, rhs: ImageGenerationSignpostProto.SecondPassImageDecoded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.FaceRestored: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".FaceRestored"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.FaceRestored, rhs: ImageGenerationSignpostProto.FaceRestored) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationSignpostProto.ImageUpscaled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ImageGenerationSignpostProto.protoMessageName + ".ImageUpscaled"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationSignpostProto.ImageUpscaled, rhs: ImageGenerationSignpostProto.ImageUpscaled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageGenerationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageGenerationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}generatedImages\0\u{1}currentSignpost\0\u{1}signposts\0\u{1}previewImage\0\u{1}scaleFactor\0\u{1}tags\0\u{1}downloadSize\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.generatedImages) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentSignpost) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.signposts) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._previewImage) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._scaleFactor) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._downloadSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.generatedImages.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.generatedImages, fieldNumber: 1)
    }
    try { if let v = self._currentSignpost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signposts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signposts, fieldNumber: 3)
    }
    try { if let v = self._previewImage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scaleFactor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 6)
    }
    try { if let v = self._downloadSize {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageGenerationResponse, rhs: ImageGenerationResponse) -> Bool {
    if lhs.generatedImages != rhs.generatedImages {return false}
    if lhs._currentSignpost != rhs._currentSignpost {return false}
    if lhs.signposts != rhs.signposts {return false}
    if lhs._previewImage != rhs._previewImage {return false}
    if lhs._scaleFactor != rhs._scaleFactor {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._downloadSize != rhs._downloadSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FileChunk"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}content\0\u{1}filename\0\u{1}offset\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FileChunk, rhs: FileChunk) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InitUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InitUploadRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}filename\0\u{1}sha256\0\u{1}totalSize\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sha256) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.sha256, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt64Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InitUploadRequest, rhs: InitUploadRequest) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UploadResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}chunkUploadSuccess\0\u{1}receivedOffset\0\u{1}message\0\u{1}filename\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.chunkUploadSuccess) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.receivedOffset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chunkUploadSuccess != false {
      try visitor.visitSingularBoolField(value: self.chunkUploadSuccess, fieldNumber: 1)
    }
    if self.receivedOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.receivedOffset, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UploadResponse, rhs: UploadResponse) -> Bool {
    if lhs.chunkUploadSuccess != rhs.chunkUploadSuccess {return false}
    if lhs.receivedOffset != rhs.receivedOffset {return false}
    if lhs.message != rhs.message {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FileUploadRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}initRequest\0\u{1}chunk\0\u{1}sharedSecret\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InitUploadRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .initRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .initRequest(v)
        }
      }()
      case 2: try {
        var v: FileChunk?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .chunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .chunk(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sharedSecret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .initRequest?: try {
      guard case .initRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .chunk?: try {
      guard case .chunk(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._sharedSecret {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FileUploadRequest, rhs: FileUploadRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs._sharedSecret != rhs._sharedSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
